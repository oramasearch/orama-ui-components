/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { ButtonProps } from "./components/internal/orama-button/orama-button";
import { ChatMarkdownLinkHref, ChatMarkdownLinkTarget, ChatMarkdownLinkTitle, CloudIndexConfig, ColorScheme, Facet, OnAnswerGeneratedCallbackProps, OnAnswerSourceClickCallbackProps, OnChatMarkdownLinkClickedCallbackProps, OnSearchCompletedCallbackProps, OnSearchResultClickCallbackProps, onStartConversationCallbackProps, ResultItemRenderFunction, ResultMap, SearchResultBySection, SourcesMap } from "./types/index";
import { TChatInteraction } from "./context/chatContext";
import { OramaClient } from "@oramacloud/client";
import { AnyOrama, Orama, SearchParams } from "@orama/orama";
import { TThemeOverrides } from "./config/theme";
import { InputProps } from "./components/internal/orama-input/orama-input";
import { ModalStatus } from "./components/internal/orama-modal/orama-modal";
import { HighlightOptions } from "@orama/highlight";
import { TThemeOverrides as TThemeOverrides1 } from "./components.d";
import { SearchResultsProps } from "./components/internal/orama-search-results/orama-search-results";
import { TextProps } from "./components/internal/orama-text/orama-text";
export { ButtonProps } from "./components/internal/orama-button/orama-button";
export { ChatMarkdownLinkHref, ChatMarkdownLinkTarget, ChatMarkdownLinkTitle, CloudIndexConfig, ColorScheme, Facet, OnAnswerGeneratedCallbackProps, OnAnswerSourceClickCallbackProps, OnChatMarkdownLinkClickedCallbackProps, OnSearchCompletedCallbackProps, OnSearchResultClickCallbackProps, onStartConversationCallbackProps, ResultItemRenderFunction, ResultMap, SearchResultBySection, SourcesMap } from "./types/index";
export { TChatInteraction } from "./context/chatContext";
export { OramaClient } from "@oramacloud/client";
export { AnyOrama, Orama, SearchParams } from "@orama/orama";
export { TThemeOverrides } from "./config/theme";
export { InputProps } from "./components/internal/orama-input/orama-input";
export { ModalStatus } from "./components/internal/orama-modal/orama-modal";
export { HighlightOptions } from "@orama/highlight";
export { TThemeOverrides as TThemeOverrides1 } from "./components.d";
export { SearchResultsProps } from "./components/internal/orama-search-results/orama-search-results";
export { TextProps } from "./components/internal/orama-text/orama-text";
export namespace Components {
    interface OramaButton {
        "as"?: ButtonProps['as'];
        "class"?: string;
        "disabled"?: boolean;
        "size": 'small' | 'medium' | 'large';
        "type"?: ButtonProps['type'];
        "variant"?: ButtonProps['variant'];
        "withTooltip"?: string;
    }
    interface OramaChat {
        "chatMarkdownLinkHref"?: ChatMarkdownLinkHref;
        "chatMarkdownLinkTarget"?: ChatMarkdownLinkTarget;
        "chatMarkdownLinkTitle"?: ChatMarkdownLinkTitle;
        "clearChatOnDisconnect"?: boolean;
        "defaultTerm"?: string;
        "focusInput"?: boolean;
        "linksRel"?: string;
        "linksTarget"?: string;
        "placeholder"?: string;
        "prompt"?: string;
        "showClearChat"?: boolean;
        "sourceBaseUrl"?: string;
        "sourcesMap"?: SourcesMap;
        "suggestions"?: string[];
        "systemPrompts"?: string[];
    }
    interface OramaChatAssistentMessage {
        "chatMarkdownLinkHref"?: ChatMarkdownLinkHref;
        "chatMarkdownLinkTarget"?: ChatMarkdownLinkTarget;
        "chatMarkdownLinkTitle"?: ChatMarkdownLinkTitle;
        "interaction": TChatInteraction;
    }
    interface OramaChatBox {
        "autoFocus": boolean;
        "chatMarkdownLinkHref"?: ChatMarkdownLinkHref;
        "chatMarkdownLinkTarget"?: ChatMarkdownLinkTarget;
        "chatMarkdownLinkTitle"?: ChatMarkdownLinkTitle;
        "clearChatOnDisconnect": boolean;
        "clientInstance"?: OramaClient | AnyOrama;
        /**
          * Component color schema
         */
        "colorScheme"?: ColorScheme;
        "index"?: CloudIndexConfig | CloudIndexConfig[];
        "linksRel"?: string;
        "linksTarget"?: string;
        "placeholder"?: string;
        "prompt"?: string;
        "sourceBaseUrl"?: string;
        "sourcesMap"?: SourcesMap;
        "suggestions"?: string[];
        "systemPrompts"?: string[];
        /**
          * Component theme customization
         */
        "themeConfig"?: Partial<TThemeOverrides>;
    }
    interface OramaChatButton {
        "active"?: boolean;
        "class"?: string;
        "highlight"?: boolean;
        "label": string;
    }
    interface OramaChatMessagesContainer {
        "chatMarkdownLinkHref"?: ChatMarkdownLinkHref;
        "chatMarkdownLinkTarget"?: ChatMarkdownLinkTarget;
        "chatMarkdownLinkTitle"?: ChatMarkdownLinkTitle;
        "interactions": TChatInteraction[];
    }
    interface OramaChatUserMessage {
        "interaction": TChatInteraction;
    }
    interface OramaDotsLoader {
    }
    interface OramaEmbed {
    }
    interface OramaFacets {
        "facets": Facet[];
        "selectedFacet": string;
        "selectedFacetChanged": (facetName: string) => void;
    }
    interface OramaFooter {
        "class"?: string;
        "colorScheme"?: Omit<ColorScheme, 'system'>;
    }
    interface OramaInput {
        "autoFocus"?: boolean;
        "defaultValue": InputProps['defaultValue'];
        "label"?: InputProps['label'];
        "labelForScreenReaders"?: InputProps['labelForScreenReaders'];
        "name": InputProps['name'];
        "placeholder"?: InputProps['placeholder'];
        "size"?: InputProps['size'];
        "type"?: InputProps['type'];
    }
    interface OramaLogoIcon {
        "size": number;
    }
    interface OramaMarkdown {
        "chatMarkdownLinkHref"?: ChatMarkdownLinkHref;
        "chatMarkdownLinkTarget"?: ChatMarkdownLinkTarget;
        "chatMarkdownLinkTitle"?: ChatMarkdownLinkTitle;
        "content": string;
    }
    interface OramaModal {
        "closeOnEscape": boolean;
        "closeOnOutsideClick": boolean;
        "mainTitle": string;
        "open": boolean;
    }
    interface OramaNavigationBar {
        "handleClose": () => void;
        "showBackButton": boolean;
        "showChatActions": boolean;
    }
    interface OramaSearch {
        "disableChat"?: boolean;
        "focusInput"?: boolean;
        "highlightDescription"?: HighlightOptions | false;
        "highlightTitle"?: HighlightOptions | false;
        "linksRel"?: string;
        "linksTarget"?: string;
        "placeholder"?: string;
        "sourceBaseUrl"?: string;
        "suggestions"?: string[];
    }
    interface OramaSearchBox {
        /**
          * Callback function used on every AI Chat link
         */
        "chatMarkdownLinkHref"?: ChatMarkdownLinkHref;
        /**
          * Callback function used on every AI Chat link target
         */
        "chatMarkdownLinkTarget"?: ChatMarkdownLinkTarget;
        /**
          * Callback function used on every AI Chat link title
         */
        "chatMarkdownLinkTitle"?: ChatMarkdownLinkTitle;
        /**
          * Placeholder for chat input
         */
        "chatPlaceholder"?: string;
        /**
          * Orama Instance
         */
        "clientInstance"?: OramaClient | AnyOrama;
        /**
          * Component color schema
         */
        "colorScheme"?: ColorScheme;
        /**
          * Disables chat capabilities
         */
        "disableChat"?: boolean;
        /**
          * Index result property to
         */
        "facetProperty"?: string;
        /**
          * Options for highlights of Search Result descriptions
         */
        "highlightDescription"?: HighlightOptions | false;
        /**
          * Options for highlights of Search Result titles
         */
        "highlightTitle"?: HighlightOptions | false;
        /**
          * Orama Index configuration  note: It will be overrided by clientInstance property
         */
        "index"?: CloudIndexConfig | CloudIndexConfig[];
        /**
          * This component can behave either as Modal or a Embed component. For Modal, a new absolute panel will be displayed on top. For Embed, Orama Search Box will be displayed as a inline component.
         */
        "layout"?: 'modal' | 'embed';
        /**
          * Used to provide linkRel to search result links
         */
        "linksRel"?: string;
        /**
          * Used to provide linkRel to search result links
         */
        "linksTarget"?: string;
        "open": boolean;
        /**
          * @deprecated it will be removed on next releases Placeholder for chat input
         */
        "placeholder"?: string;
        /**
          * Used to render a custom icom per result. It should return a local asset path.
         */
        "resultItemRender"?: ResultItemRenderFunction;
        /**
          * Used to map dataset result properties to the expected SearchBox properties
         */
        "resultMap"?: Partial<ResultMap>;
        /**
          * Parameters forwarded to Orama Client.
         */
        "searchParams"?: SearchParams<Orama<AnyOrama | OramaClient>>;
        /**
          * Placeholder for search input
         */
        "searchPlaceholder"?: string;
        /**
          * Used to provide source base URL for the Search Results
         */
        "sourceBaseUrl"?: string;
        /**
          * Used to map Chat result sources to expected Orama Chat properties
         */
        "sourcesMap"?: SourcesMap;
        /**
          * List of initial questions for Orama Chat
         */
        "suggestions"?: string[];
        /**
          * Component theme customization
         */
        "themeConfig"?: Partial<TThemeOverrides>;
    }
    interface OramaSearchButton {
        "colorScheme"?: ColorScheme;
        "size": 'small' | 'medium' | 'large';
        "themeConfig"?: Partial<TThemeOverrides>;
    }
    interface OramaSearchResults {
        "error": boolean;
        "highlightDescription"?: HighlightOptions | false;
        "highlightTitle"?: HighlightOptions | false;
        "linksRel"?: string;
        "linksTarget"?: string;
        "loading": boolean;
        "searchTerm": SearchResultsProps['searchTerm'];
        "sections": SearchResultBySection[];
        "setChatTerm": (term: string) => void;
        "sourceBaseUrl"?: string;
        "suggestions"?: string[];
    }
    interface OramaSlidingPanel {
        "backdrop": boolean;
        "closed": () => void;
        "open": boolean;
    }
    interface OramaSources {
        "linksRel"?: string;
        "linksTarget"?: string;
        "sourceBaseURL"?: string;
        "sources": any;
        "sourcesMap"?: SourcesMap;
    }
    interface OramaSuggestions {
        "as": 'chips' | 'list';
        "icon"?: Node;
        "suggestionClicked": (suggestion: string) => void;
        "suggestions": string[];
    }
    interface OramaText {
        /**
          * optionally change text alignment
         */
        "align"?: TextProps['align'];
        /**
          * it defines the HTML tag to be used
         */
        "as"?: TextProps['as'];
        "bold"?: boolean;
        /**
          * the optional class name
         */
        "class"?: string;
        /**
          * show as inactive
         */
        "inactive"?: TextProps['inactive'];
        /**
          * it defines how it should look like
         */
        "styledAs"?: TextProps['styledAs'];
        /**
          * optionally change variant style - default is primary
         */
        "variant": TextProps['variant'];
    }
    interface OramaTextarea {
        "autoFocus": boolean;
        "maxRows": number | string;
        "minRows": number | string;
        "placeholder": string;
        "value": string | null;
    }
    interface OramaToggler {
        "performInitialAnimation": boolean;
    }
}
export interface OramaChatCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLOramaChatElement;
}
export interface OramaChatBoxCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLOramaChatBoxElement;
}
export interface OramaChatMessagesContainerCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLOramaChatMessagesContainerElement;
}
export interface OramaInputCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLOramaInputElement;
}
export interface OramaMarkdownCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLOramaMarkdownElement;
}
export interface OramaModalCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLOramaModalElement;
}
export interface OramaSearchCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLOramaSearchElement;
}
export interface OramaSearchBoxCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLOramaSearchBoxElement;
}
export interface OramaSearchResultsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLOramaSearchResultsElement;
}
export interface OramaSourcesCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLOramaSourcesElement;
}
declare global {
    interface HTMLOramaButtonElement extends Components.OramaButton, HTMLStencilElement {
    }
    var HTMLOramaButtonElement: {
        prototype: HTMLOramaButtonElement;
        new (): HTMLOramaButtonElement;
    };
    interface HTMLOramaChatElementEventMap {
        "answerGenerated": OnAnswerGeneratedCallbackProps;
        "clearChat": void;
        "startConversation": onStartConversationCallbackProps;
    }
    interface HTMLOramaChatElement extends Components.OramaChat, HTMLStencilElement {
        addEventListener<K extends keyof HTMLOramaChatElementEventMap>(type: K, listener: (this: HTMLOramaChatElement, ev: OramaChatCustomEvent<HTMLOramaChatElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLOramaChatElementEventMap>(type: K, listener: (this: HTMLOramaChatElement, ev: OramaChatCustomEvent<HTMLOramaChatElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLOramaChatElement: {
        prototype: HTMLOramaChatElement;
        new (): HTMLOramaChatElement;
    };
    interface HTMLOramaChatAssistentMessageElement extends Components.OramaChatAssistentMessage, HTMLStencilElement {
    }
    var HTMLOramaChatAssistentMessageElement: {
        prototype: HTMLOramaChatAssistentMessageElement;
        new (): HTMLOramaChatAssistentMessageElement;
    };
    interface HTMLOramaChatBoxElementEventMap {
        "answerGenerated": OnAnswerGeneratedCallbackProps;
        "clearChat": void;
        "startConversation": onStartConversationCallbackProps;
        "answerSourceClick": OnAnswerSourceClickCallbackProps;
        "chatMarkdownLinkClicked": OnChatMarkdownLinkClickedCallbackProps;
    }
    interface HTMLOramaChatBoxElement extends Components.OramaChatBox, HTMLStencilElement {
        addEventListener<K extends keyof HTMLOramaChatBoxElementEventMap>(type: K, listener: (this: HTMLOramaChatBoxElement, ev: OramaChatBoxCustomEvent<HTMLOramaChatBoxElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLOramaChatBoxElementEventMap>(type: K, listener: (this: HTMLOramaChatBoxElement, ev: OramaChatBoxCustomEvent<HTMLOramaChatBoxElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLOramaChatBoxElement: {
        prototype: HTMLOramaChatBoxElement;
        new (): HTMLOramaChatBoxElement;
    };
    interface HTMLOramaChatButtonElement extends Components.OramaChatButton, HTMLStencilElement {
    }
    var HTMLOramaChatButtonElement: {
        prototype: HTMLOramaChatButtonElement;
        new (): HTMLOramaChatButtonElement;
    };
    interface HTMLOramaChatMessagesContainerElementEventMap {
        "answerGenerated": OnAnswerGeneratedCallbackProps;
    }
    interface HTMLOramaChatMessagesContainerElement extends Components.OramaChatMessagesContainer, HTMLStencilElement {
        addEventListener<K extends keyof HTMLOramaChatMessagesContainerElementEventMap>(type: K, listener: (this: HTMLOramaChatMessagesContainerElement, ev: OramaChatMessagesContainerCustomEvent<HTMLOramaChatMessagesContainerElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLOramaChatMessagesContainerElementEventMap>(type: K, listener: (this: HTMLOramaChatMessagesContainerElement, ev: OramaChatMessagesContainerCustomEvent<HTMLOramaChatMessagesContainerElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLOramaChatMessagesContainerElement: {
        prototype: HTMLOramaChatMessagesContainerElement;
        new (): HTMLOramaChatMessagesContainerElement;
    };
    interface HTMLOramaChatUserMessageElement extends Components.OramaChatUserMessage, HTMLStencilElement {
    }
    var HTMLOramaChatUserMessageElement: {
        prototype: HTMLOramaChatUserMessageElement;
        new (): HTMLOramaChatUserMessageElement;
    };
    interface HTMLOramaDotsLoaderElement extends Components.OramaDotsLoader, HTMLStencilElement {
    }
    var HTMLOramaDotsLoaderElement: {
        prototype: HTMLOramaDotsLoaderElement;
        new (): HTMLOramaDotsLoaderElement;
    };
    interface HTMLOramaEmbedElement extends Components.OramaEmbed, HTMLStencilElement {
    }
    var HTMLOramaEmbedElement: {
        prototype: HTMLOramaEmbedElement;
        new (): HTMLOramaEmbedElement;
    };
    interface HTMLOramaFacetsElement extends Components.OramaFacets, HTMLStencilElement {
    }
    var HTMLOramaFacetsElement: {
        prototype: HTMLOramaFacetsElement;
        new (): HTMLOramaFacetsElement;
    };
    interface HTMLOramaFooterElement extends Components.OramaFooter, HTMLStencilElement {
    }
    var HTMLOramaFooterElement: {
        prototype: HTMLOramaFooterElement;
        new (): HTMLOramaFooterElement;
    };
    interface HTMLOramaInputElementEventMap {
        "resetValue": void;
    }
    interface HTMLOramaInputElement extends Components.OramaInput, HTMLStencilElement {
        addEventListener<K extends keyof HTMLOramaInputElementEventMap>(type: K, listener: (this: HTMLOramaInputElement, ev: OramaInputCustomEvent<HTMLOramaInputElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLOramaInputElementEventMap>(type: K, listener: (this: HTMLOramaInputElement, ev: OramaInputCustomEvent<HTMLOramaInputElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLOramaInputElement: {
        prototype: HTMLOramaInputElement;
        new (): HTMLOramaInputElement;
    };
    interface HTMLOramaLogoIconElement extends Components.OramaLogoIcon, HTMLStencilElement {
    }
    var HTMLOramaLogoIconElement: {
        prototype: HTMLOramaLogoIconElement;
        new (): HTMLOramaLogoIconElement;
    };
    interface HTMLOramaMarkdownElementEventMap {
        "chatMarkdownLinkClicked": OnChatMarkdownLinkClickedCallbackProps;
    }
    interface HTMLOramaMarkdownElement extends Components.OramaMarkdown, HTMLStencilElement {
        addEventListener<K extends keyof HTMLOramaMarkdownElementEventMap>(type: K, listener: (this: HTMLOramaMarkdownElement, ev: OramaMarkdownCustomEvent<HTMLOramaMarkdownElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLOramaMarkdownElementEventMap>(type: K, listener: (this: HTMLOramaMarkdownElement, ev: OramaMarkdownCustomEvent<HTMLOramaMarkdownElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLOramaMarkdownElement: {
        prototype: HTMLOramaMarkdownElement;
        new (): HTMLOramaMarkdownElement;
    };
    interface HTMLOramaModalElementEventMap {
        "modalStatusChanged": ModalStatus;
    }
    interface HTMLOramaModalElement extends Components.OramaModal, HTMLStencilElement {
        addEventListener<K extends keyof HTMLOramaModalElementEventMap>(type: K, listener: (this: HTMLOramaModalElement, ev: OramaModalCustomEvent<HTMLOramaModalElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLOramaModalElementEventMap>(type: K, listener: (this: HTMLOramaModalElement, ev: OramaModalCustomEvent<HTMLOramaModalElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLOramaModalElement: {
        prototype: HTMLOramaModalElement;
        new (): HTMLOramaModalElement;
    };
    interface HTMLOramaNavigationBarElement extends Components.OramaNavigationBar, HTMLStencilElement {
    }
    var HTMLOramaNavigationBarElement: {
        prototype: HTMLOramaNavigationBarElement;
        new (): HTMLOramaNavigationBarElement;
    };
    interface HTMLOramaSearchElementEventMap {
        "searchCompleted": OnSearchCompletedCallbackProps;
        "answerGenerated": OnAnswerGeneratedCallbackProps;
    }
    interface HTMLOramaSearchElement extends Components.OramaSearch, HTMLStencilElement {
        addEventListener<K extends keyof HTMLOramaSearchElementEventMap>(type: K, listener: (this: HTMLOramaSearchElement, ev: OramaSearchCustomEvent<HTMLOramaSearchElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLOramaSearchElementEventMap>(type: K, listener: (this: HTMLOramaSearchElement, ev: OramaSearchCustomEvent<HTMLOramaSearchElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLOramaSearchElement: {
        prototype: HTMLOramaSearchElement;
        new (): HTMLOramaSearchElement;
    };
    interface HTMLOramaSearchBoxElementEventMap {
        "searchCompleted": OnSearchCompletedCallbackProps;
        "searchResultClick": OnSearchResultClickCallbackProps;
        "clearChat": void;
        "startConversation": onStartConversationCallbackProps;
        "answerGenerated": OnAnswerGeneratedCallbackProps;
        "answerSourceClick": OnAnswerSourceClickCallbackProps;
        "chatMarkdownLinkClicked": OnChatMarkdownLinkClickedCallbackProps;
    }
    interface HTMLOramaSearchBoxElement extends Components.OramaSearchBox, HTMLStencilElement {
        addEventListener<K extends keyof HTMLOramaSearchBoxElementEventMap>(type: K, listener: (this: HTMLOramaSearchBoxElement, ev: OramaSearchBoxCustomEvent<HTMLOramaSearchBoxElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLOramaSearchBoxElementEventMap>(type: K, listener: (this: HTMLOramaSearchBoxElement, ev: OramaSearchBoxCustomEvent<HTMLOramaSearchBoxElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLOramaSearchBoxElement: {
        prototype: HTMLOramaSearchBoxElement;
        new (): HTMLOramaSearchBoxElement;
    };
    interface HTMLOramaSearchButtonElement extends Components.OramaSearchButton, HTMLStencilElement {
    }
    var HTMLOramaSearchButtonElement: {
        prototype: HTMLOramaSearchButtonElement;
        new (): HTMLOramaSearchButtonElement;
    };
    interface HTMLOramaSearchResultsElementEventMap {
        "searchResultClick": OnSearchResultClickCallbackProps;
    }
    interface HTMLOramaSearchResultsElement extends Components.OramaSearchResults, HTMLStencilElement {
        addEventListener<K extends keyof HTMLOramaSearchResultsElementEventMap>(type: K, listener: (this: HTMLOramaSearchResultsElement, ev: OramaSearchResultsCustomEvent<HTMLOramaSearchResultsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLOramaSearchResultsElementEventMap>(type: K, listener: (this: HTMLOramaSearchResultsElement, ev: OramaSearchResultsCustomEvent<HTMLOramaSearchResultsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLOramaSearchResultsElement: {
        prototype: HTMLOramaSearchResultsElement;
        new (): HTMLOramaSearchResultsElement;
    };
    interface HTMLOramaSlidingPanelElement extends Components.OramaSlidingPanel, HTMLStencilElement {
    }
    var HTMLOramaSlidingPanelElement: {
        prototype: HTMLOramaSlidingPanelElement;
        new (): HTMLOramaSlidingPanelElement;
    };
    interface HTMLOramaSourcesElementEventMap {
        "answerSourceClick": OnAnswerSourceClickCallbackProps;
    }
    interface HTMLOramaSourcesElement extends Components.OramaSources, HTMLStencilElement {
        addEventListener<K extends keyof HTMLOramaSourcesElementEventMap>(type: K, listener: (this: HTMLOramaSourcesElement, ev: OramaSourcesCustomEvent<HTMLOramaSourcesElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLOramaSourcesElementEventMap>(type: K, listener: (this: HTMLOramaSourcesElement, ev: OramaSourcesCustomEvent<HTMLOramaSourcesElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLOramaSourcesElement: {
        prototype: HTMLOramaSourcesElement;
        new (): HTMLOramaSourcesElement;
    };
    interface HTMLOramaSuggestionsElement extends Components.OramaSuggestions, HTMLStencilElement {
    }
    var HTMLOramaSuggestionsElement: {
        prototype: HTMLOramaSuggestionsElement;
        new (): HTMLOramaSuggestionsElement;
    };
    interface HTMLOramaTextElement extends Components.OramaText, HTMLStencilElement {
    }
    var HTMLOramaTextElement: {
        prototype: HTMLOramaTextElement;
        new (): HTMLOramaTextElement;
    };
    interface HTMLOramaTextareaElement extends Components.OramaTextarea, HTMLStencilElement {
    }
    var HTMLOramaTextareaElement: {
        prototype: HTMLOramaTextareaElement;
        new (): HTMLOramaTextareaElement;
    };
    interface HTMLOramaTogglerElement extends Components.OramaToggler, HTMLStencilElement {
    }
    var HTMLOramaTogglerElement: {
        prototype: HTMLOramaTogglerElement;
        new (): HTMLOramaTogglerElement;
    };
    interface HTMLElementTagNameMap {
        "orama-button": HTMLOramaButtonElement;
        "orama-chat": HTMLOramaChatElement;
        "orama-chat-assistent-message": HTMLOramaChatAssistentMessageElement;
        "orama-chat-box": HTMLOramaChatBoxElement;
        "orama-chat-button": HTMLOramaChatButtonElement;
        "orama-chat-messages-container": HTMLOramaChatMessagesContainerElement;
        "orama-chat-user-message": HTMLOramaChatUserMessageElement;
        "orama-dots-loader": HTMLOramaDotsLoaderElement;
        "orama-embed": HTMLOramaEmbedElement;
        "orama-facets": HTMLOramaFacetsElement;
        "orama-footer": HTMLOramaFooterElement;
        "orama-input": HTMLOramaInputElement;
        "orama-logo-icon": HTMLOramaLogoIconElement;
        "orama-markdown": HTMLOramaMarkdownElement;
        "orama-modal": HTMLOramaModalElement;
        "orama-navigation-bar": HTMLOramaNavigationBarElement;
        "orama-search": HTMLOramaSearchElement;
        "orama-search-box": HTMLOramaSearchBoxElement;
        "orama-search-button": HTMLOramaSearchButtonElement;
        "orama-search-results": HTMLOramaSearchResultsElement;
        "orama-sliding-panel": HTMLOramaSlidingPanelElement;
        "orama-sources": HTMLOramaSourcesElement;
        "orama-suggestions": HTMLOramaSuggestionsElement;
        "orama-text": HTMLOramaTextElement;
        "orama-textarea": HTMLOramaTextareaElement;
        "orama-toggler": HTMLOramaTogglerElement;
    }
}
declare namespace LocalJSX {
    interface OramaButton {
        "as"?: ButtonProps['as'];
        "class"?: string;
        "disabled"?: boolean;
        "size"?: 'small' | 'medium' | 'large';
        "type"?: ButtonProps['type'];
        "variant"?: ButtonProps['variant'];
        "withTooltip"?: string;
    }
    interface OramaChat {
        "chatMarkdownLinkHref"?: ChatMarkdownLinkHref;
        "chatMarkdownLinkTarget"?: ChatMarkdownLinkTarget;
        "chatMarkdownLinkTitle"?: ChatMarkdownLinkTitle;
        "clearChatOnDisconnect"?: boolean;
        "defaultTerm"?: string;
        "focusInput"?: boolean;
        "linksRel"?: string;
        "linksTarget"?: string;
        "onAnswerGenerated"?: (event: OramaChatCustomEvent<OnAnswerGeneratedCallbackProps>) => void;
        "onClearChat"?: (event: OramaChatCustomEvent<void>) => void;
        "onStartConversation"?: (event: OramaChatCustomEvent<onStartConversationCallbackProps>) => void;
        "placeholder"?: string;
        "prompt"?: string;
        "showClearChat"?: boolean;
        "sourceBaseUrl"?: string;
        "sourcesMap"?: SourcesMap;
        "suggestions"?: string[];
        "systemPrompts"?: string[];
    }
    interface OramaChatAssistentMessage {
        "chatMarkdownLinkHref"?: ChatMarkdownLinkHref;
        "chatMarkdownLinkTarget"?: ChatMarkdownLinkTarget;
        "chatMarkdownLinkTitle"?: ChatMarkdownLinkTitle;
        "interaction"?: TChatInteraction;
    }
    interface OramaChatBox {
        "autoFocus"?: boolean;
        "chatMarkdownLinkHref"?: ChatMarkdownLinkHref;
        "chatMarkdownLinkTarget"?: ChatMarkdownLinkTarget;
        "chatMarkdownLinkTitle"?: ChatMarkdownLinkTitle;
        "clearChatOnDisconnect"?: boolean;
        "clientInstance"?: OramaClient | AnyOrama;
        /**
          * Component color schema
         */
        "colorScheme"?: ColorScheme;
        "index"?: CloudIndexConfig | CloudIndexConfig[];
        "linksRel"?: string;
        "linksTarget"?: string;
        /**
          * Fired when answer generation is successfully completed
         */
        "onAnswerGenerated"?: (event: OramaChatBoxCustomEvent<OnAnswerGeneratedCallbackProps>) => void;
        /**
          * Fired when user clicks on answer source
         */
        "onAnswerSourceClick"?: (event: OramaChatBoxCustomEvent<OnAnswerSourceClickCallbackProps>) => void;
        /**
          * Fired when user clicks on chat markdown link
         */
        "onChatMarkdownLinkClicked"?: (event: OramaChatBoxCustomEvent<OnChatMarkdownLinkClickedCallbackProps>) => void;
        /**
          * Fired when the chat is cleared
         */
        "onClearChat"?: (event: OramaChatBoxCustomEvent<void>) => void;
        /**
          * Fired as soon as the conversation is started
         */
        "onStartConversation"?: (event: OramaChatBoxCustomEvent<onStartConversationCallbackProps>) => void;
        "placeholder"?: string;
        "prompt"?: string;
        "sourceBaseUrl"?: string;
        "sourcesMap"?: SourcesMap;
        "suggestions"?: string[];
        "systemPrompts"?: string[];
        /**
          * Component theme customization
         */
        "themeConfig"?: Partial<TThemeOverrides>;
    }
    interface OramaChatButton {
        "active"?: boolean;
        "class"?: string;
        "highlight"?: boolean;
        "label"?: string;
    }
    interface OramaChatMessagesContainer {
        "chatMarkdownLinkHref"?: ChatMarkdownLinkHref;
        "chatMarkdownLinkTarget"?: ChatMarkdownLinkTarget;
        "chatMarkdownLinkTitle"?: ChatMarkdownLinkTitle;
        "interactions"?: TChatInteraction[];
        "onAnswerGenerated"?: (event: OramaChatMessagesContainerCustomEvent<OnAnswerGeneratedCallbackProps>) => void;
    }
    interface OramaChatUserMessage {
        "interaction"?: TChatInteraction;
    }
    interface OramaDotsLoader {
    }
    interface OramaEmbed {
    }
    interface OramaFacets {
        "facets"?: Facet[];
        "selectedFacet"?: string;
        "selectedFacetChanged"?: (facetName: string) => void;
    }
    interface OramaFooter {
        "class"?: string;
        "colorScheme"?: Omit<ColorScheme, 'system'>;
    }
    interface OramaInput {
        "autoFocus"?: boolean;
        "defaultValue"?: InputProps['defaultValue'];
        "label"?: InputProps['label'];
        "labelForScreenReaders"?: InputProps['labelForScreenReaders'];
        "name"?: InputProps['name'];
        "onResetValue"?: (event: OramaInputCustomEvent<void>) => void;
        "placeholder"?: InputProps['placeholder'];
        "size"?: InputProps['size'];
        "type"?: InputProps['type'];
    }
    interface OramaLogoIcon {
        "size"?: number;
    }
    interface OramaMarkdown {
        "chatMarkdownLinkHref"?: ChatMarkdownLinkHref;
        "chatMarkdownLinkTarget"?: ChatMarkdownLinkTarget;
        "chatMarkdownLinkTitle"?: ChatMarkdownLinkTitle;
        "content"?: string;
        "onChatMarkdownLinkClicked"?: (event: OramaMarkdownCustomEvent<OnChatMarkdownLinkClickedCallbackProps>) => void;
    }
    interface OramaModal {
        "closeOnEscape"?: boolean;
        "closeOnOutsideClick"?: boolean;
        "mainTitle"?: string;
        "onModalStatusChanged"?: (event: OramaModalCustomEvent<ModalStatus>) => void;
        "open"?: boolean;
    }
    interface OramaNavigationBar {
        "handleClose"?: () => void;
        "showBackButton"?: boolean;
        "showChatActions"?: boolean;
    }
    interface OramaSearch {
        "disableChat"?: boolean;
        "focusInput"?: boolean;
        "highlightDescription"?: HighlightOptions | false;
        "highlightTitle"?: HighlightOptions | false;
        "linksRel"?: string;
        "linksTarget"?: string;
        "onAnswerGenerated"?: (event: OramaSearchCustomEvent<OnAnswerGeneratedCallbackProps>) => void;
        "onSearchCompleted"?: (event: OramaSearchCustomEvent<OnSearchCompletedCallbackProps>) => void;
        "placeholder"?: string;
        "sourceBaseUrl"?: string;
        "suggestions"?: string[];
    }
    interface OramaSearchBox {
        /**
          * Callback function used on every AI Chat link
         */
        "chatMarkdownLinkHref"?: ChatMarkdownLinkHref;
        /**
          * Callback function used on every AI Chat link target
         */
        "chatMarkdownLinkTarget"?: ChatMarkdownLinkTarget;
        /**
          * Callback function used on every AI Chat link title
         */
        "chatMarkdownLinkTitle"?: ChatMarkdownLinkTitle;
        /**
          * Placeholder for chat input
         */
        "chatPlaceholder"?: string;
        /**
          * Orama Instance
         */
        "clientInstance"?: OramaClient | AnyOrama;
        /**
          * Component color schema
         */
        "colorScheme"?: ColorScheme;
        /**
          * Disables chat capabilities
         */
        "disableChat"?: boolean;
        /**
          * Index result property to
         */
        "facetProperty"?: string;
        /**
          * Options for highlights of Search Result descriptions
         */
        "highlightDescription"?: HighlightOptions | false;
        /**
          * Options for highlights of Search Result titles
         */
        "highlightTitle"?: HighlightOptions | false;
        /**
          * Orama Index configuration  note: It will be overrided by clientInstance property
         */
        "index"?: CloudIndexConfig | CloudIndexConfig[];
        /**
          * This component can behave either as Modal or a Embed component. For Modal, a new absolute panel will be displayed on top. For Embed, Orama Search Box will be displayed as a inline component.
         */
        "layout"?: 'modal' | 'embed';
        /**
          * Used to provide linkRel to search result links
         */
        "linksRel"?: string;
        /**
          * Used to provide linkRel to search result links
         */
        "linksTarget"?: string;
        /**
          * Fired when answer generation is successfully completed
         */
        "onAnswerGenerated"?: (event: OramaSearchBoxCustomEvent<OnAnswerGeneratedCallbackProps>) => void;
        /**
          * Fired when user clicks on answer source
         */
        "onAnswerSourceClick"?: (event: OramaSearchBoxCustomEvent<OnAnswerSourceClickCallbackProps>) => void;
        /**
          * Fired when user clicks on chat markdown link
         */
        "onChatMarkdownLinkClicked"?: (event: OramaSearchBoxCustomEvent<OnChatMarkdownLinkClickedCallbackProps>) => void;
        /**
          * Fired when the chat is cleared
         */
        "onClearChat"?: (event: OramaSearchBoxCustomEvent<void>) => void;
        /**
          * Fired when search successfully resolves
         */
        "onSearchCompleted"?: (event: OramaSearchBoxCustomEvent<OnSearchCompletedCallbackProps>) => void;
        /**
          * Fired when user clicks on search result
         */
        "onSearchResultClick"?: (event: OramaSearchBoxCustomEvent<OnSearchResultClickCallbackProps>) => void;
        /**
          * Fired as soon as the conversation is started
         */
        "onStartConversation"?: (event: OramaSearchBoxCustomEvent<onStartConversationCallbackProps>) => void;
        "open"?: boolean;
        /**
          * @deprecated it will be removed on next releases Placeholder for chat input
         */
        "placeholder"?: string;
        /**
          * Used to render a custom icom per result. It should return a local asset path.
         */
        "resultItemRender"?: ResultItemRenderFunction;
        /**
          * Used to map dataset result properties to the expected SearchBox properties
         */
        "resultMap"?: Partial<ResultMap>;
        /**
          * Parameters forwarded to Orama Client.
         */
        "searchParams"?: SearchParams<Orama<AnyOrama | OramaClient>>;
        /**
          * Placeholder for search input
         */
        "searchPlaceholder"?: string;
        /**
          * Used to provide source base URL for the Search Results
         */
        "sourceBaseUrl"?: string;
        /**
          * Used to map Chat result sources to expected Orama Chat properties
         */
        "sourcesMap"?: SourcesMap;
        /**
          * List of initial questions for Orama Chat
         */
        "suggestions"?: string[];
        /**
          * Component theme customization
         */
        "themeConfig"?: Partial<TThemeOverrides>;
    }
    interface OramaSearchButton {
        "colorScheme"?: ColorScheme;
        "size"?: 'small' | 'medium' | 'large';
        "themeConfig"?: Partial<TThemeOverrides>;
    }
    interface OramaSearchResults {
        "error"?: boolean;
        "highlightDescription"?: HighlightOptions | false;
        "highlightTitle"?: HighlightOptions | false;
        "linksRel"?: string;
        "linksTarget"?: string;
        "loading"?: boolean;
        "onSearchResultClick"?: (event: OramaSearchResultsCustomEvent<OnSearchResultClickCallbackProps>) => void;
        "searchTerm"?: SearchResultsProps['searchTerm'];
        "sections"?: SearchResultBySection[];
        "setChatTerm"?: (term: string) => void;
        "sourceBaseUrl"?: string;
        "suggestions"?: string[];
    }
    interface OramaSlidingPanel {
        "backdrop"?: boolean;
        "closed"?: () => void;
        "open"?: boolean;
    }
    interface OramaSources {
        "linksRel"?: string;
        "linksTarget"?: string;
        "onAnswerSourceClick"?: (event: OramaSourcesCustomEvent<OnAnswerSourceClickCallbackProps>) => void;
        "sourceBaseURL"?: string;
        "sources"?: any;
        "sourcesMap"?: SourcesMap;
    }
    interface OramaSuggestions {
        "as"?: 'chips' | 'list';
        "icon"?: Node;
        "suggestionClicked"?: (suggestion: string) => void;
        "suggestions"?: string[];
    }
    interface OramaText {
        /**
          * optionally change text alignment
         */
        "align"?: TextProps['align'];
        /**
          * it defines the HTML tag to be used
         */
        "as"?: TextProps['as'];
        "bold"?: boolean;
        /**
          * the optional class name
         */
        "class"?: string;
        /**
          * show as inactive
         */
        "inactive"?: TextProps['inactive'];
        /**
          * it defines how it should look like
         */
        "styledAs"?: TextProps['styledAs'];
        /**
          * optionally change variant style - default is primary
         */
        "variant"?: TextProps['variant'];
    }
    interface OramaTextarea {
        "autoFocus"?: boolean;
        "maxRows"?: number | string;
        "minRows"?: number | string;
        "placeholder"?: string;
        "value"?: string | null;
    }
    interface OramaToggler {
        "performInitialAnimation"?: boolean;
    }
    interface IntrinsicElements {
        "orama-button": OramaButton;
        "orama-chat": OramaChat;
        "orama-chat-assistent-message": OramaChatAssistentMessage;
        "orama-chat-box": OramaChatBox;
        "orama-chat-button": OramaChatButton;
        "orama-chat-messages-container": OramaChatMessagesContainer;
        "orama-chat-user-message": OramaChatUserMessage;
        "orama-dots-loader": OramaDotsLoader;
        "orama-embed": OramaEmbed;
        "orama-facets": OramaFacets;
        "orama-footer": OramaFooter;
        "orama-input": OramaInput;
        "orama-logo-icon": OramaLogoIcon;
        "orama-markdown": OramaMarkdown;
        "orama-modal": OramaModal;
        "orama-navigation-bar": OramaNavigationBar;
        "orama-search": OramaSearch;
        "orama-search-box": OramaSearchBox;
        "orama-search-button": OramaSearchButton;
        "orama-search-results": OramaSearchResults;
        "orama-sliding-panel": OramaSlidingPanel;
        "orama-sources": OramaSources;
        "orama-suggestions": OramaSuggestions;
        "orama-text": OramaText;
        "orama-textarea": OramaTextarea;
        "orama-toggler": OramaToggler;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "orama-button": LocalJSX.OramaButton & JSXBase.HTMLAttributes<HTMLOramaButtonElement>;
            "orama-chat": LocalJSX.OramaChat & JSXBase.HTMLAttributes<HTMLOramaChatElement>;
            "orama-chat-assistent-message": LocalJSX.OramaChatAssistentMessage & JSXBase.HTMLAttributes<HTMLOramaChatAssistentMessageElement>;
            "orama-chat-box": LocalJSX.OramaChatBox & JSXBase.HTMLAttributes<HTMLOramaChatBoxElement>;
            "orama-chat-button": LocalJSX.OramaChatButton & JSXBase.HTMLAttributes<HTMLOramaChatButtonElement>;
            "orama-chat-messages-container": LocalJSX.OramaChatMessagesContainer & JSXBase.HTMLAttributes<HTMLOramaChatMessagesContainerElement>;
            "orama-chat-user-message": LocalJSX.OramaChatUserMessage & JSXBase.HTMLAttributes<HTMLOramaChatUserMessageElement>;
            "orama-dots-loader": LocalJSX.OramaDotsLoader & JSXBase.HTMLAttributes<HTMLOramaDotsLoaderElement>;
            "orama-embed": LocalJSX.OramaEmbed & JSXBase.HTMLAttributes<HTMLOramaEmbedElement>;
            "orama-facets": LocalJSX.OramaFacets & JSXBase.HTMLAttributes<HTMLOramaFacetsElement>;
            "orama-footer": LocalJSX.OramaFooter & JSXBase.HTMLAttributes<HTMLOramaFooterElement>;
            "orama-input": LocalJSX.OramaInput & JSXBase.HTMLAttributes<HTMLOramaInputElement>;
            "orama-logo-icon": LocalJSX.OramaLogoIcon & JSXBase.HTMLAttributes<HTMLOramaLogoIconElement>;
            "orama-markdown": LocalJSX.OramaMarkdown & JSXBase.HTMLAttributes<HTMLOramaMarkdownElement>;
            "orama-modal": LocalJSX.OramaModal & JSXBase.HTMLAttributes<HTMLOramaModalElement>;
            "orama-navigation-bar": LocalJSX.OramaNavigationBar & JSXBase.HTMLAttributes<HTMLOramaNavigationBarElement>;
            "orama-search": LocalJSX.OramaSearch & JSXBase.HTMLAttributes<HTMLOramaSearchElement>;
            "orama-search-box": LocalJSX.OramaSearchBox & JSXBase.HTMLAttributes<HTMLOramaSearchBoxElement>;
            "orama-search-button": LocalJSX.OramaSearchButton & JSXBase.HTMLAttributes<HTMLOramaSearchButtonElement>;
            "orama-search-results": LocalJSX.OramaSearchResults & JSXBase.HTMLAttributes<HTMLOramaSearchResultsElement>;
            "orama-sliding-panel": LocalJSX.OramaSlidingPanel & JSXBase.HTMLAttributes<HTMLOramaSlidingPanelElement>;
            "orama-sources": LocalJSX.OramaSources & JSXBase.HTMLAttributes<HTMLOramaSourcesElement>;
            "orama-suggestions": LocalJSX.OramaSuggestions & JSXBase.HTMLAttributes<HTMLOramaSuggestionsElement>;
            "orama-text": LocalJSX.OramaText & JSXBase.HTMLAttributes<HTMLOramaTextElement>;
            "orama-textarea": LocalJSX.OramaTextarea & JSXBase.HTMLAttributes<HTMLOramaTextareaElement>;
            "orama-toggler": LocalJSX.OramaToggler & JSXBase.HTMLAttributes<HTMLOramaTogglerElement>;
        }
    }
}
